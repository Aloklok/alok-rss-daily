import type { VercelRequest, VercelResponse } from '@vercel/node';
import { JSDOM } from 'jsdom';
import { Readability } from '@mozilla/readability';

export default async function handler(req: VercelRequest, res: VercelResponse) {
    const { url } = req.query;

    if (!url || typeof url !== 'string') {
        return res.status(400).json({ message: 'URL parameter is required.' });
    }

    try {
        // Add browser-like headers to reduce chances of being blocked
        const fetchRes = await fetch(String(url), {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
                'Accept-Language': 'en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache',
                'Referer': new URL(String(url)).origin
            },
            credentials: 'omit',
            redirect: 'follow',
            timeout: 30000
        });
        if (!fetchRes.ok) {
            throw new Error(`Failed to fetch URL with status: ${fetchRes.status}`);
        }
        const html = await fetchRes.text();
        const doc = new JSDOM(html, { url: String(url) });

        const reader = new Readability(doc.window.document);
        const article = reader.parse();

        // If Readability succeeded with substantial content, return it.
        if (article && article.content && (article.content || '').trim().length > 200) {
            console.log('Readability produced full content for URL:', url);
            return res.status(200).json({
                title: article.title,
                content: article.content, // This is sanitized HTML from Readability
                source: article.siteName || new URL(String(url)).hostname,
            });
        }

        // Heuristic: if the raw HTML looks like a client-side SPA (empty app root),
        // attempt a headless render. Use a serverless-friendly Chromium when available
        // (puppeteer-core + @sparticvs/chromium or chrome-aws-lambda) or fall back to
        // the local `puppeteer` package. Headless rendering can be gated by
        // ENABLE_HEADLESS_RENDER=1 environment variable.
        const rawHtml = html || '';
        const looksLikeSpa = /<div[^>]+id=("|')(app|root)("|')/i.test(rawHtml) || /<script[^>]+type=("|')module("|')/i.test(rawHtml) || rawHtml.trim().length < 500;
        const shouldTryHeadless = looksLikeSpa && process.env.ENABLE_HEADLESS_RENDER === '1';
        
        console.log('Debug - HTML Analysis:', {
            htmlLength: rawHtml.trim().length,
            looksLikeSpa,
            enableHeadlessRender: process.env.ENABLE_HEADLESS_RENDER,
            shouldTryHeadless
        });

        if (shouldTryHeadless) {
            let browser = null;
            try {
                console.log('Debug - Loading packages...');
                const chromiumPkg: any = await import('@sparticuz/chromium');
                const puppeteerCore: any = await import('puppeteer-core');
                console.log('Debug - Packages loaded successfully. Launching browser...');
                
                browser = await puppeteerCore.launch({
                    args: chromiumPkg.args || ['--no-sandbox', '--disable-setuid-sandbox'],
                    executablePath: await (chromiumPkg.executablePath ? chromiumPkg.executablePath() : chromiumPkg.executablePath),
                    headless: chromiumPkg.headless ?? true,
                });

                console.log('Debug - Browser launched successfully. Creating new page...');
                const page = await browser.newPage();
                console.log('Debug - Page created. Setting user agent...');
                await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36');
                console.log('Debug - Navigating to URL:', url);
                await page.goto(String(url), { waitUntil: 'networkidle2', timeout: 25000 });
                console.log('Debug - Navigation complete. Getting page content...');
                const renderedHtml = await page.content();
                console.log('Debug - Content retrieved. Length:', renderedHtml.length);

                const renderedDoc = new JSDOM(renderedHtml, { url: String(url) });
                const renderedReader = new Readability(renderedDoc.window.document);
                const renderedArticle = renderedReader.parse();
                
                if (renderedArticle && renderedArticle.content && (renderedArticle.content || '').trim().length > 100) {
                    console.log('Headless Readability succeeded for URL:', url);
                    return res.status(200).json({
                        title: renderedArticle.title,
                        content: renderedArticle.content,
                        source: renderedArticle.siteName || new URL(String(url)).hostname,
                    });
                }

                console.log('Headless render did not yield useful content for URL:', url);
            } catch (err) {
                console.error('Headless render attempt failed:', err);
                // continue to remaining fallbacks
            } finally {
                if (browser) {
                    await browser.close();
                }
            }


        // Fallback 1: look for semantic container like <article> or <main> or common selectors
        const docEl = doc.window.document;
        const selectors = ['article', 'main', '#content', '.article', '.post', '.entry-content', '.post-content'];
        for (const sel of selectors) {
            const el = docEl.querySelector(sel);
            if (el && el.textContent && el.textContent.trim().length > 200) {
                const title = docEl.querySelector('meta[property="og:title"]')?.getAttribute('content') || docEl.title || '';
                return res.status(200).json({
                    title: title || (article && article.title) || '',
                    content: el.innerHTML,
                    source: new URL(String(url)).hostname,
                });
            }
        }

        // Fallback 2: choose the largest textual container (div/section) by text length
        const candidates = Array.from(docEl.querySelectorAll('div, section')) as Element[];
        let best: Element | null = null;
        let bestLen = 0;
        for (const c of candidates) {
            const text = c.textContent || '';
            const len = text.trim().length;
            if (len > bestLen) {
                bestLen = len;
                best = c;
            }
        }
        if (best && bestLen > 200) {
            const title = docEl.querySelector('meta[property="og:title"]')?.getAttribute('content') || docEl.title || '';
            return res.status(200).json({
                title: title || (article && article.title) || '',
                content: best.innerHTML,
                source: new URL(String(url)).hostname,
            });
        }

        // Last resort: return body HTML if reasonably sized
        const bodyHtml = docEl.body?.innerHTML || '';
        if (bodyHtml.trim().length > 0) {
            const title = docEl.querySelector('meta[property="og:title"]')?.getAttribute('content') || docEl.title || '';
            return res.status(200).json({
                title: title || (article && article.title) || '',
                content: bodyHtml,
                source: new URL(String(url)).hostname,
            });
        }

        throw new Error('Readability could not parse the article and no fallback content found.');

    } catch (error: any) {
        console.error(`Error in /api/readability for url: ${url}`, error);
        res.status(500).json({ message: 'Error processing article', error: error.message });
    }
}
